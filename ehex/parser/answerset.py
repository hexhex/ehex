#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by TatSu.
#
#    https://pypi.python.org/pypi/tatsu/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import print_function, division, absolute_import, unicode_literals

import sys

from tatsu.buffering import Buffer
from tatsu.parsing import Parser
from tatsu.parsing import tatsumasu
from tatsu.util import re, generic_main  # noqa


KEYWORDS = {}  # type: ignore


class HEXAnswerSetBuffer(Buffer):
    def __init__(
        self,
        text,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=None,
        namechars='',
        **kwargs
    ):
        super(HEXAnswerSetBuffer, self).__init__(
            text,
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            namechars=namechars,
            **kwargs
        )


class HEXAnswerSetParser(Parser):
    def __init__(
        self,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=None,
        left_recursion=True,
        parseinfo=True,
        keywords=None,
        namechars='',
        buffer_class=HEXAnswerSetBuffer,
        **kwargs
    ):
        if keywords is None:
            keywords = KEYWORDS
        super(HEXAnswerSetParser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            left_recursion=left_recursion,
            parseinfo=parseinfo,
            keywords=keywords,
            namechars=namechars,
            buffer_class=buffer_class,
            **kwargs
        )

    @tatsumasu()
    def _start_(self):  # noqa
        self._result_()
        self._check_eof()

    @tatsumasu()
    def _result_(self):  # noqa
        self._answer_sets_()

    @tatsumasu()
    def _answer_sets_(self):  # noqa

        def block0():
            self._answer_set_()
        self._closure(block0)

    @tatsumasu('set')
    def _answer_set_(self):  # noqa
        self._CURLY_OPEN_()
        self._cut()
        self._literals_()
        self.name_last_node('@')
        self._CURLY_CLOSE_()

    @tatsumasu()
    def _literals_(self):  # noqa

        def sep0():
            with self._group():
                self._COMMA_()

        def block0():
            self._literal_()
        self._gather(block0, sep0)

    @tatsumasu()
    def _literal_(self):  # noqa
        with self._choice():
            with self._option():
                self._epistemic_rejection_()
            with self._option():
                self._strong_negated_atom_()
            with self._option():
                self._atom_()
            self._error('no available options')

    @tatsumasu('Atom')
    def _atom_(self):  # noqa
        self._predicate_symbol_()
        self.name_last_node('symbol')
        with self._optional():
            self._PAREN_OPEN_()
            with self._optional():
                self._terms_()
                self.name_last_node('arguments')
            self._PAREN_CLOSE_()
        self.ast._define(
            ['arguments', 'symbol'],
            []
        )

    @tatsumasu('StrongNegation')
    def _strong_negated_atom_(self):  # noqa
        with self._choice():
            with self._option():
                self._MINUS_()
                self.name_last_node('op')
                self._cut()
                self._atom_()
                self.name_last_node('atom')
            with self._option():
                with self._optional():
                    self._AUX_MARKER_()
                self._SNEG_PREFIX_()
                self._cut()
                self._void()
                self.name_last_node('op')
                self._pattern(r'_')
                self._atom_()
                self.name_last_node('atom')
            self._error('no available options')
        self.ast._define(
            ['atom', 'op'],
            []
        )

    @tatsumasu()
    def _epistemic_rejection_(self):  # noqa
        self._AUX_MARKER_()
        self._GUESS_PREFIX_()
        self._cut()
        self._PAREN_OPEN_()
        with self._group():
            with self._choice():
                with self._option():
                    self._modal_()
                with self._option():
                    self._default_negated_modal_()
                self._error('no available options')
        self.name_last_node('@')
        self._PAREN_CLOSE_()

    @tatsumasu('Modal')
    def _modal_(self):  # noqa
        with self._optional():
            self._AUX_MARKER_()
        with self._group():
            with self._choice():
                with self._option():
                    self._K_PREFIX_()
                with self._option():
                    self._M_PREFIX_()
                self._error('no available options')
        self.name_last_node('op')
        self._cut()
        self._pattern(r'_')
        with self._group():
            with self._choice():
                with self._option():
                    self._strong_negated_atom_()
                with self._option():
                    self._atom_()
                self._error('no available options')
        self.name_last_node('literal')
        self.ast._define(
            ['literal', 'op'],
            []
        )

    @tatsumasu('DefaultNegation')
    def _default_negated_modal_(self):  # noqa
        self._AUX_MARKER_()
        self._DNEG_PREFIX_()
        self.name_last_node('op')
        self._cut()
        self._pattern(r'_')
        self._modal_()
        self.name_last_node('literal')
        self.ast._define(
            ['literal', 'op'],
            []
        )

    @tatsumasu()
    def _predicate_symbol_(self):  # noqa
        self._ID_()

    @tatsumasu()
    def _terms_(self):  # noqa

        def sep0():
            with self._group():
                self._COMMA_()

        def block0():
            self._term_()
        self._positive_gather(block0, sep0)

    @tatsumasu()
    def _term_(self):  # noqa
        with self._choice():
            with self._option():
                self._functional_()
            with self._option():
                self._constant_()
            with self._option():
                self._negative_term_()
            self._error('no available options')

    @tatsumasu('FunctionalTerm')
    def _functional_(self):  # noqa
        self._function_symbol_()
        self.name_last_node('symbol')
        self._PAREN_OPEN_()
        self._cut()
        with self._optional():
            self._terms_()
            self.name_last_node('arguments')
        self._PAREN_CLOSE_()
        self.ast._define(
            ['arguments', 'symbol'],
            []
        )

    @tatsumasu()
    def _function_symbol_(self):  # noqa
        self._ID_()

    @tatsumasu('NegativeTerm')
    def _negative_term_(self):  # noqa
        self._MINUS_()
        self._cut()
        self._term_()

    @tatsumasu('ConstantTerm')
    def _constant_(self):  # noqa
        with self._choice():
            with self._option():
                self._STRING_()
            with self._option():
                self._ID_()
            with self._option():
                self._NUMBER_()
            self._error('no available options')

    @tatsumasu()
    def _ID_(self):  # noqa
        self._pattern(r'[a-z][a-zA-Z0-9_]*')

    @tatsumasu()
    def _STRING_(self):  # noqa
        self._pattern(r'"(?:\\"|[^"])*"')

    @tatsumasu('int')
    def _NUMBER_(self):  # noqa
        self._pattern(r'0|\d+')

    @tatsumasu()
    def _COMMA_(self):  # noqa
        self._token(',')

    @tatsumasu()
    def _PLUS_(self):  # noqa
        self._token('+')

    @tatsumasu()
    def _MINUS_(self):  # noqa
        self._token('-')

    @tatsumasu()
    def _TIMES_(self):  # noqa
        self._token('*')

    @tatsumasu()
    def _DIV_(self):  # noqa
        self._token('/')

    @tatsumasu()
    def _PAREN_OPEN_(self):  # noqa
        self._token('(')

    @tatsumasu()
    def _PAREN_CLOSE_(self):  # noqa
        self._token(')')

    @tatsumasu()
    def _CURLY_OPEN_(self):  # noqa
        self._token('{')

    @tatsumasu()
    def _CURLY_CLOSE_(self):  # noqa
        self._token('}')

    @tatsumasu()
    def _AUX_MARKER_(self):  # noqa
        self._pattern(r'aux__')

    @tatsumasu()
    def _DNEG_PREFIX_(self):  # noqa
        self._pattern(r'NOT')

    @tatsumasu()
    def _K_PREFIX_(self):  # noqa
        self._pattern(r'K')

    @tatsumasu()
    def _M_PREFIX_(self):  # noqa
        self._pattern(r'M')

    @tatsumasu()
    def _SNEG_PREFIX_(self):  # noqa
        self._pattern(r'NEG')

    @tatsumasu()
    def _GUESS_PREFIX_(self):  # noqa
        self._pattern(r'IN')


class HEXAnswerSetSemantics(object):
    def start(self, ast):  # noqa
        return ast

    def result(self, ast):  # noqa
        return ast

    def answer_sets(self, ast):  # noqa
        return ast

    def answer_set(self, ast):  # noqa
        return ast

    def literals(self, ast):  # noqa
        return ast

    def literal(self, ast):  # noqa
        return ast

    def atom(self, ast):  # noqa
        return ast

    def strong_negated_atom(self, ast):  # noqa
        return ast

    def epistemic_rejection(self, ast):  # noqa
        return ast

    def modal(self, ast):  # noqa
        return ast

    def default_negated_modal(self, ast):  # noqa
        return ast

    def predicate_symbol(self, ast):  # noqa
        return ast

    def terms(self, ast):  # noqa
        return ast

    def term(self, ast):  # noqa
        return ast

    def functional(self, ast):  # noqa
        return ast

    def function_symbol(self, ast):  # noqa
        return ast

    def negative_term(self, ast):  # noqa
        return ast

    def constant(self, ast):  # noqa
        return ast

    def ID(self, ast):  # noqa
        return ast

    def STRING(self, ast):  # noqa
        return ast

    def NUMBER(self, ast):  # noqa
        return ast

    def COMMA(self, ast):  # noqa
        return ast

    def PLUS(self, ast):  # noqa
        return ast

    def MINUS(self, ast):  # noqa
        return ast

    def TIMES(self, ast):  # noqa
        return ast

    def DIV(self, ast):  # noqa
        return ast

    def PAREN_OPEN(self, ast):  # noqa
        return ast

    def PAREN_CLOSE(self, ast):  # noqa
        return ast

    def CURLY_OPEN(self, ast):  # noqa
        return ast

    def CURLY_CLOSE(self, ast):  # noqa
        return ast

    def AUX_MARKER(self, ast):  # noqa
        return ast

    def DNEG_PREFIX(self, ast):  # noqa
        return ast

    def K_PREFIX(self, ast):  # noqa
        return ast

    def M_PREFIX(self, ast):  # noqa
        return ast

    def SNEG_PREFIX(self, ast):  # noqa
        return ast

    def GUESS_PREFIX(self, ast):  # noqa
        return ast


def main(filename, start='start', **kwargs):
    if not filename or filename == '-':
        text = sys.stdin.read()
    else:
        with open(filename) as f:
            text = f.read()
    parser = HEXAnswerSetParser()
    return parser.parse(text, start=start, filename=filename, **kwargs)


if __name__ == '__main__':
    import json
    from tatsu.util import asjson

    ast = generic_main(main, HEXAnswerSetParser, name='HEXAnswerSet')
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(asjson(ast), indent=2))
    print()
