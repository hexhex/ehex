#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by Grako.
#
#    https://pypi.python.org/pypi/grako/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import print_function, division, absolute_import, unicode_literals

from grako.buffering import Buffer
from grako.parsing import graken, Parser
from grako.util import re, RE_FLAGS, generic_main  # noqa


__all__ = [
    'HEXAnswerSetParser',
    'HEXAnswerSetSemantics',
    'main'
]

KEYWORDS = {}


class HEXAnswerSetBuffer(Buffer):
    def __init__(
        self,
        text,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=None,
        namechars='',
        **kwargs
    ):
        super(HEXAnswerSetBuffer, self).__init__(
            text,
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            namechars=namechars,
            **kwargs
        )


class HEXAnswerSetParser(Parser):
    def __init__(
        self,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=None,
        left_recursion=False,
        parseinfo=True,
        keywords=None,
        namechars='',
        buffer_class=HEXAnswerSetBuffer,
        **kwargs
    ):
        if keywords is None:
            keywords = KEYWORDS
        super(HEXAnswerSetParser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            left_recursion=left_recursion,
            parseinfo=parseinfo,
            keywords=keywords,
            namechars=namechars,
            buffer_class=buffer_class,
            **kwargs
        )

    @graken()
    def _start_(self):
        self._result_()
        self._check_eof()

    @graken()
    def _result_(self):
        self._answer_sets_()

    @graken()
    def _answer_sets_(self):

        def block0():
            self._answer_set_()
        self._closure(block0)

    @graken('set')
    def _answer_set_(self):
        self._CURLY_OPEN_()
        self._cut()
        self._literals_()
        self.name_last_node('@')
        self._CURLY_CLOSE_()

    @graken()
    def _literals_(self):

        def sep0():
            with self._group():
                self._COMMA_()

        def block0():
            self._literal_()
        self._closure(block0, sep=sep0)

    @graken()
    def _literal_(self):
        with self._choice():
            with self._option():
                self._atom_()
            with self._option():
                self._default_negated_literal_()
            with self._option():
                self._modal_literal_()
            with self._option():
                self._strong_negated_atom_()
            self._error('no available options')

    @graken('DefaultNegation')
    def _default_negated_literal_(self):
        self._AUX_MARKER_()
        self._DNEG_PREFIX_()
        self._cut()
        self._pattern(r'_')
        with self._group():
            with self._choice():
                with self._option():
                    self._modal_literal_()
                with self._option():
                    self._strong_negated_atom_()
                with self._option():
                    self._atom_()
                self._error('no available options')
        self.name_last_node('literal')
        self.ast._define(
            ['literal'],
            []
        )

    @graken('Modal')
    def _modal_literal_(self):
        with self._optional():
            self._AUX_MARKER_()
        with self._group():
            with self._choice():
                with self._option():
                    self._K_PREFIX_()
                with self._option():
                    self._M_PREFIX_()
                self._error('no available options')
        self.name_last_node('op')
        self._cut()
        self._pattern(r'_')
        with self._group():
            with self._choice():
                with self._option():
                    self._strong_negated_atom_()
                with self._option():
                    self._atom_()
                self._error('no available options')
        self.name_last_node('literal')
        self.ast._define(
            ['literal', 'op'],
            []
        )

    @graken('Atom')
    def _atom_(self):
        with self._ifnot():
            with self._group():
                with self._optional():
                    self._AUX_MARKER_()
                with self._group():
                    with self._choice():
                        with self._option():
                            self._SNEG_PREFIX_()
                        with self._option():
                            self._K_PREFIX_()
                        with self._option():
                            self._M_PREFIX_()
                        with self._option():
                            self._DNEG_PREFIX_()
                        self._error('no available options')
        self._cut()
        self._predicate_symbol_()
        self.name_last_node('symbol')
        with self._optional():
            self._PAREN_OPEN_()
            with self._optional():
                self._terms_()
                self.name_last_node('arguments')
            self._PAREN_CLOSE_()
        self.ast._define(
            ['arguments', 'symbol'],
            []
        )

    @graken('StrongNegation')
    def _strong_negated_atom_(self):
        with self._choice():
            with self._option():
                self._MINUS_()
                self.name_last_node('op')
                self._cut()
                self._atom_()
                self.name_last_node('atom')
            with self._option():
                with self._optional():
                    self._AUX_MARKER_()
                self._SNEG_PREFIX_()
                self._cut()
                self._void()
                self.name_last_node('op')
                self._pattern(r'_')
                self._atom_()
                self.name_last_node('atom')
            self._error('no available options')
        self.ast._define(
            ['atom', 'op'],
            []
        )

    @graken()
    def _predicate_symbol_(self):
        self._ID_()

    @graken()
    def _terms_(self):

        def sep0():
            with self._group():
                self._COMMA_()

        def block0():
            self._term_()
        self._positive_closure(block0, sep=sep0)

    @graken()
    def _term_(self):
        with self._choice():
            with self._option():
                self._arith_expr_()
            with self._option():
                self._basic_term_()
            self._error('no available options')

    @graken()
    def _arith_expr_(self):
        with self._choice():
            with self._option():
                self._additive_()
            with self._option():
                self._multiplicative_()
            self._error('no available options')

    @graken('AdditiveTerm')
    def _additive_(self):
        self._arith_term_()
        self.add_last_node_to_name('@')

        def block1():
            with self._group():
                with self._choice():
                    with self._option():
                        self._PLUS_()
                    with self._option():
                        self._MINUS_()
                    self._error('no available options')
            self.name_last_node('@')
            self._cut()
            self._arith_term_()
            self.name_last_node('@')
        self._positive_closure(block1)

    @graken()
    def _arith_term_(self):
        with self._choice():
            with self._option():
                self._multiplicative_()
            with self._option():
                self._basic_term_()
            self._error('no available options')

    @graken('MultiplicativeTerm')
    def _multiplicative_(self):
        self._arith_factor_()
        self.add_last_node_to_name('@')

        def block1():
            with self._group():
                with self._choice():
                    with self._option():
                        self._TIMES_()
                    with self._option():
                        self._DIV_()
                    self._error('no available options')
            self.name_last_node('@')
            self._cut()
            self._arith_factor_()
            self.name_last_node('@')
        self._positive_closure(block1)

    @graken()
    def _arith_factor_(self):
        self._basic_term_()

    @graken()
    def _basic_term_(self):
        with self._choice():
            with self._option():
                self._functional_()
            with self._option():
                self._constant_()
            with self._option():
                self._variable_()
            with self._option():
                self._subterm_()
            with self._option():
                self._negative_term_()
            self._error('no available options')

    @graken('FunctionalTerm')
    def _functional_(self):
        self._function_symbol_()
        self.name_last_node('symbol')
        self._PAREN_OPEN_()
        self._cut()
        with self._optional():
            self._terms_()
            self.name_last_node('arguments')
        self._PAREN_CLOSE_()
        self.ast._define(
            ['arguments', 'symbol'],
            []
        )

    @graken()
    def _function_symbol_(self):
        self._ID_()

    @graken('SubTerm')
    def _subterm_(self):
        self._PAREN_OPEN_()
        self._cut()
        self._term_()
        self.name_last_node('@')
        self._PAREN_CLOSE_()

    @graken('NegativeTerm')
    def _negative_term_(self):
        self._MINUS_()
        self._cut()
        self._term_()

    @graken('ConstantTerm')
    def _constant_(self):
        with self._choice():
            with self._option():
                self._STRING_()
            with self._option():
                self._ID_()
            with self._option():
                self._NUMBER_()
            self._error('no available options')

    @graken('VariableTerm')
    def _variable_(self):
        with self._choice():
            with self._option():
                self._ANONYMOUS_VARIABLE_()
            with self._option():
                self._VARIABLE_()
            self._error('no available options')

    @graken()
    def _ID_(self):
        self._pattern(r'[a-z][a-zA-Z0-9_]*')

    @graken()
    def _VARIABLE_(self):
        self._pattern(r'[A-Z][a-zA-Z0-9_]*')

    @graken()
    def _STRING_(self):
        self._pattern(r'"(?:\\"|[^"])*"')

    @graken('int')
    def _NUMBER_(self):
        self._pattern(r'0|\d+')

    @graken()
    def _ANONYMOUS_VARIABLE_(self):
        self._token('_')

    @graken()
    def _COMMA_(self):
        self._token(',')

    @graken()
    def _PLUS_(self):
        self._token('+')

    @graken()
    def _MINUS_(self):
        self._token('-')

    @graken()
    def _TIMES_(self):
        self._token('*')

    @graken()
    def _DIV_(self):
        self._token('/')

    @graken()
    def _PAREN_OPEN_(self):
        self._token('(')

    @graken()
    def _PAREN_CLOSE_(self):
        self._token(')')

    @graken()
    def _CURLY_OPEN_(self):
        self._token('{')

    @graken()
    def _CURLY_CLOSE_(self):
        self._token('}')

    @graken()
    def _AUX_MARKER_(self):
        self._pattern(r'aux__')

    @graken()
    def _DNEG_PREFIX_(self):
        self._pattern(r'NOT')

    @graken()
    def _K_PREFIX_(self):
        self._pattern(r'K')

    @graken()
    def _M_PREFIX_(self):
        self._pattern(r'M')

    @graken()
    def _SNEG_PREFIX_(self):
        self._pattern(r'NEG')


class HEXAnswerSetSemantics(object):
    def start(self, ast):
        return ast

    def result(self, ast):
        return ast

    def answer_sets(self, ast):
        return ast

    def answer_set(self, ast):
        return ast

    def literals(self, ast):
        return ast

    def literal(self, ast):
        return ast

    def default_negated_literal(self, ast):
        return ast

    def modal_literal(self, ast):
        return ast

    def atom(self, ast):
        return ast

    def strong_negated_atom(self, ast):
        return ast

    def predicate_symbol(self, ast):
        return ast

    def terms(self, ast):
        return ast

    def term(self, ast):
        return ast

    def arith_expr(self, ast):
        return ast

    def additive(self, ast):
        return ast

    def arith_term(self, ast):
        return ast

    def multiplicative(self, ast):
        return ast

    def arith_factor(self, ast):
        return ast

    def basic_term(self, ast):
        return ast

    def functional(self, ast):
        return ast

    def function_symbol(self, ast):
        return ast

    def subterm(self, ast):
        return ast

    def negative_term(self, ast):
        return ast

    def constant(self, ast):
        return ast

    def variable(self, ast):
        return ast

    def ID(self, ast):
        return ast

    def VARIABLE(self, ast):
        return ast

    def STRING(self, ast):
        return ast

    def NUMBER(self, ast):
        return ast

    def ANONYMOUS_VARIABLE(self, ast):
        return ast

    def COMMA(self, ast):
        return ast

    def PLUS(self, ast):
        return ast

    def MINUS(self, ast):
        return ast

    def TIMES(self, ast):
        return ast

    def DIV(self, ast):
        return ast

    def PAREN_OPEN(self, ast):
        return ast

    def PAREN_CLOSE(self, ast):
        return ast

    def CURLY_OPEN(self, ast):
        return ast

    def CURLY_CLOSE(self, ast):
        return ast

    def AUX_MARKER(self, ast):
        return ast

    def DNEG_PREFIX(self, ast):
        return ast

    def K_PREFIX(self, ast):
        return ast

    def M_PREFIX(self, ast):
        return ast

    def SNEG_PREFIX(self, ast):
        return ast


def main(filename, startrule, **kwargs):
    with open(filename) as f:
        text = f.read()
    parser = HEXAnswerSetParser(parseinfo=False)
    return parser.parse(text, startrule, filename=filename, **kwargs)


if __name__ == '__main__':
    import json
    ast = generic_main(main, HEXAnswerSetParser, name='HEXAnswerSet')
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(ast, indent=2))
    print()
