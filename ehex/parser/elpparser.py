#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by TatSu.
#
#    https://pypi.python.org/pypi/tatsu/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import generator_stop

import sys

from tatsu.buffering import Buffer
from tatsu.parsing import Parser
from tatsu.parsing import tatsumasu, leftrec, nomemo
from tatsu.parsing import leftrec, nomemo  # noqa
from tatsu.util import re, generic_main  # noqa


KEYWORDS = {
    'not',
}  # type: ignore


class ELPBuffer(Buffer):
    def __init__(
        self,
        text,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re='%([^\\n]*?)$',
        ignorecase=None,
        namechars='',
        **kwargs
    ):
        super().__init__(
            text,
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            namechars=namechars,
            **kwargs
        )


class ELPParser(Parser):
    def __init__(
        self,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re='%([^\\n]*?)$',
        ignorecase=None,
        left_recursion=True,
        parseinfo=True,
        keywords=None,
        namechars='',
        tokenizercls=ELPBuffer,
        **kwargs
    ):
        if keywords is None:
            keywords = KEYWORDS
        super().__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            left_recursion=left_recursion,
            parseinfo=parseinfo,
            keywords=keywords,
            namechars=namechars,
            tokenizercls=tokenizercls,
            **kwargs
        )

    @tatsumasu('Program')
    def _program_(self):  # noqa

        def block1():
            with self._ifnot():
                self._check_eof()
            self._rule_()
        self._closure(block1)
        self.name_last_node('rules')
        self._check_eof()
        self.ast._define(
            ['rules'],
            []
        )

    @tatsumasu('Rule')
    def _rule_(self):  # noqa
        with self._choice():
            with self._option():
                self._CONS_()
                self._cut()
                with self._group():
                    with self._choice():
                        with self._option():
                            self._body_()
                        with self._option():
                            self._empty_closure()
                        self._error('expecting one of: body')
                self.name_last_node('body')
                self._token('.')
            with self._option():
                self._head_()
                self.name_last_node('head')
                self._cut()
                with self._group():
                    with self._choice():
                        with self._option():
                            self._CONS_()
                            with self._group():
                                with self._choice():
                                    with self._option():
                                        self._body_()
                                    with self._option():
                                        self._empty_closure()
                                    self._error('expecting one of: body')
                            self.name_last_node('body')
                        with self._option():
                            self._empty_closure()
                            self.name_last_node('body')
                        self._error('expecting one of: CONS')
                self._token('.')
            self._error('expecting one of: :- CONS choice_atom disjunction head ←')
        self.ast._define(
            ['body', 'head'],
            []
        )

    @tatsumasu()
    def _head_(self):  # noqa
        with self._choice():
            with self._option():
                self._disjunction_()
            with self._option():
                self._choice_atom_()
            self._error('expecting one of: choice_atom classical_atom disjunction term {')

    @tatsumasu()
    def _body_(self):  # noqa
        self._body_literal_()
        self.add_last_node_to_name('@')

        def block1():
            self._LAND_()
            self._cut()
            self._body_literal_()
            self.add_last_node_to_name('@')
        self._closure(block1)

    @tatsumasu()
    def _body_literal_(self):  # noqa
        with self._choice():
            with self._option():
                self._modal_literal_()
            with self._option():
                with self._choice():
                    with self._option():
                        self._naf_aggregate_()
                    with self._option():
                        self._naf_literal_()
                    self._error('expecting one of: LNOT NAME NOT aggregate_atom aggregate_name builtin_atom classical_atom naf_aggregate naf_literal not term')
            self._error('expecting one of: K M NOT aggregate_atom builtin_atom classical_atom modal_literal naf_aggregate naf_literal not')

    @tatsumasu('Disjunction')
    def _disjunction_(self):  # noqa
        self._classical_atom_()
        self.add_last_node_to_name('atoms')

        def block1():
            self._LOR_()
            self._cut()
            self._classical_atom_()
            self.add_last_node_to_name('atoms')
        self._closure(block1)
        self.ast._define(
            [],
            ['atoms']
        )

    @tatsumasu()
    def _naf_literals_(self):  # noqa
        self._naf_literal_()
        self.add_last_node_to_name('@')

        def block1():
            self._LAND_()
            self._cut()
            self._naf_literal_()
            self.add_last_node_to_name('@')
        self._closure(block1)

    @tatsumasu('StandardLiteral')
    def _naf_literal_(self):  # noqa
        with self._choice():
            with self._option():
                self._NOT_()
                self.name_last_node('negation')
                self._cut()
                self._classical_atom_()
                self.name_last_node('atom')
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._builtin_atom_()
                        with self._option():
                            self._classical_atom_()
                        self._error('expecting one of: LNOT NAME builtin_atom classical_atom term')
                self.name_last_node('atom')
            self._error('expecting one of: LNOT NAME NOT builtin_atom classical_atom not term')
        self.ast._define(
            ['atom', 'negation'],
            []
        )

    @tatsumasu('Atom')
    def _classical_atom_(self):  # noqa
        with self._optional():
            self._LNOT_()
            self.name_last_node('negation')
            self._cut()
        self._NAME_()
        self.name_last_node('name')
        with self._group():
            with self._choice():
                with self._option():
                    self._token('(')
                    self._cut()
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._terms_()
                            with self._option():
                                self._empty_closure()
                            self._error('expecting one of: terms')
                    self.name_last_node('args')
                    self._token(')')
                with self._option():
                    self._empty_closure()
                    self.name_last_node('args')
                self._error('expecting one of: (')
        self.ast._define(
            ['args', 'name', 'negation'],
            []
        )

    @tatsumasu('BuiltinAtom')
    def _builtin_atom_(self):  # noqa
        self._term_()
        self.name_last_node('left')
        self._rel_op_()
        self.name_last_node('rel')
        self._term_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'rel', 'right'],
            []
        )

    @tatsumasu('ChoiceAtom')
    def _choice_atom_(self):  # noqa
        with self._optional():
            self._term_()
            self.name_last_node('left')
            self._rel_op_()
            self.name_last_node('left_rel')
        self._token('{')
        self._cut()
        with self._group():
            with self._choice():
                with self._option():
                    self._choice_elements_()
                with self._option():
                    self._empty_closure()
                self._error('expecting one of: choice_elements')
        self.name_last_node('elements')
        self._token('}')
        with self._optional():
            self._rel_op_()
            self.name_last_node('right_rel')
            self._term_()
            self.name_last_node('right')
        self.ast._define(
            ['elements', 'left', 'left_rel', 'right', 'right_rel'],
            []
        )

    @tatsumasu()
    def _choice_elements_(self):  # noqa
        self._choice_element_()
        self.add_last_node_to_name('@')

        def block1():
            self._token(';')
            self._cut()
            self._choice_element_()
            self.add_last_node_to_name('@')
        self._closure(block1)

    @tatsumasu('ChoiceElement')
    def _choice_element_(self):  # noqa
        self._classical_atom_()
        self.name_last_node('atom')
        self._cut()
        with self._group():
            with self._choice():
                with self._option():
                    self._token(':')
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._naf_literals_()
                            with self._option():
                                self._empty_closure()
                            self._error('expecting one of: naf_literals')
                    self.name_last_node('literals')
                with self._option():
                    self._empty_closure()
                    self.name_last_node('literals')
                self._error('expecting one of: :')
        self.ast._define(
            ['atom', 'literals'],
            []
        )

    @tatsumasu('AggregateLiteral')
    def _naf_aggregate_(self):  # noqa
        with self._optional():
            self._NOT_()
        self.name_last_node('negation')
        self._aggregate_atom_()
        self.name_last_node('atom')
        self.ast._define(
            ['atom', 'negation'],
            []
        )

    @tatsumasu('AggregateAtom')
    def _aggregate_atom_(self):  # noqa
        with self._optional():
            self._term_()
            self.name_last_node('left')
            self._rel_op_()
            self.name_last_node('left_rel')
        self._aggregate_name_()
        self.name_last_node('name')
        self._cut()
        self._token('{')
        with self._optional():
            self._aggregate_elements_()
        self.name_last_node('elements')
        self._token('}')
        with self._optional():
            self._rel_op_()
            self.name_last_node('right_rel')
            self._term_()
            self.name_last_node('right')
        self.ast._define(
            ['elements', 'left', 'left_rel', 'name', 'right', 'right_rel'],
            []
        )

    @tatsumasu()
    def _aggregate_elements_(self):  # noqa
        self._aggregate_element_()
        self.add_last_node_to_name('@')

        def block1():
            self._token(';')
            self._cut()
            self._aggregate_element_()
            self.add_last_node_to_name('@')
        self._closure(block1)

    @tatsumasu('AggregateElement')
    def _aggregate_element_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._terms_()
                with self._option():
                    self._empty_closure()
                self._error('expecting one of: terms')
        self.name_last_node('terms')
        with self._group():
            with self._choice():
                with self._option():
                    self._token(':')
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._naf_literals_()
                            with self._option():
                                self._empty_closure()
                            self._error('expecting one of: naf_literals')
                    self.name_last_node('literals')
                with self._option():
                    self._empty_closure()
                    self.name_last_node('literals')
                self._error('expecting one of: :')
        self.ast._define(
            ['literals', 'terms'],
            []
        )

    @tatsumasu()
    def _aggregate_name_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('#count')
            with self._option():
                self._token('#max')
            with self._option():
                self._token('#min')
            with self._option():
                self._token('#sum')
            self._error('expecting one of: #count #max #min #sum')

    @tatsumasu()
    def _rel_op_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('<=')
            with self._option():
                self._token('>=')
            with self._option():
                self._token('<>')
            with self._option():
                self._token('!=')
            with self._option():
                self._token('<')
            with self._option():
                self._token('>')
            with self._option():
                self._token('=')
            self._error('expecting one of: != < <= <> = > >=')

    @tatsumasu()
    def _LAND_(self):  # noqa
        with self._choice():
            with self._option():
                self._token(',')
            with self._option():
                self._token('&')
            with self._option():
                self._token('∧')
            self._error('expecting one of: & , ∧')

    @tatsumasu()
    def _LOR_(self):  # noqa
        with self._choice():
            with self._option():
                self._token(';')
            with self._option():
                self._token('|')
            with self._option():
                self._token('v')
            with self._option():
                self._token('∨')
            self._error('expecting one of: ; v | ∨')

    @tatsumasu()
    def _LNOT_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('-')
            with self._option():
                self._token('¬')
            self._error('expecting one of: - ¬')

    @tatsumasu()
    def _NOT_(self):  # noqa
        self._token('not')

    @tatsumasu()
    def _CONS_(self):  # noqa
        with self._choice():
            with self._option():
                self._token(':-')
            with self._option():
                self._token('←')
            self._error('expecting one of: :- ←')

    @tatsumasu()
    def _terms_(self):  # noqa
        self._term_()
        self.add_last_node_to_name('@')

        def block1():
            self._token(',')
            self._cut()
            self._term_()
            self.add_last_node_to_name('@')
        self._closure(block1)

    @tatsumasu()
    def _term_(self):  # noqa
        with self._choice():
            with self._option():
                self._interval_term_()
            with self._option():
                self._single_term_()
            self._error('expecting one of: arithmetic_term basic_term interval_term single_term')

    @tatsumasu('IntervalTerm')
    def _interval_term_(self):  # noqa
        self._single_term_()
        self.name_last_node('@')

        def block1():
            self._token('..')
            self._cut()
            self._single_term_()
            self.name_last_node('@')
        self._positive_closure(block1)

    @tatsumasu()
    def _single_term_(self):  # noqa
        with self._choice():
            with self._option():
                self._arithmetic_term_()
            with self._option():
                self._basic_term_()
            self._error('expecting one of: arithmetic_term basic_term functional_term negative_term simple_term sub_term')

    @tatsumasu('ArithmeticTerm')
    def _arithmetic_term_(self):  # noqa
        self._basic_term_()
        self.name_last_node('@')

        def block1():
            self._arith_op_()
            self.name_last_node('@')
            self._cut()
            self._basic_term_()
            self.name_last_node('@')
        self._positive_closure(block1)

    @tatsumasu()
    def _basic_term_(self):  # noqa
        with self._choice():
            with self._option():
                self._functional_term_()
            with self._option():
                self._simple_term_()
            with self._option():
                self._sub_term_()
            with self._option():
                self._negative_term_()
            self._error('expecting one of: ( - NAME constant_term functional_term negative_term simple_term sub_term variable_term')

    @tatsumasu('FunctionalTerm')
    def _functional_term_(self):  # noqa
        self._NAME_()
        self.name_last_node('name')
        self._token('(')
        self._cut()
        with self._group():
            with self._choice():
                with self._option():
                    self._terms_()
                with self._option():
                    self._empty_closure()
                self._error('expecting one of: terms')
        self.name_last_node('args')
        self._token(')')
        self.ast._define(
            ['args', 'name'],
            []
        )

    @tatsumasu('SubTerm')
    def _sub_term_(self):  # noqa
        self._token('(')
        self._cut()
        self._term_()
        self.name_last_node('@')
        self._token(')')

    @tatsumasu('NegativeTerm')
    def _negative_term_(self):  # noqa
        self._token('-')
        self._cut()
        self._term_()
        self.name_last_node('@')

    @tatsumasu()
    def _simple_term_(self):  # noqa
        with self._choice():
            with self._option():
                self._constant_term_()
            with self._option():
                self._variable_term_()
            self._error('expecting one of: NAME NUMBER STRING VARIABLE _ constant_term variable_term')

    @tatsumasu('ConstantTerm')
    def _constant_term_(self):  # noqa
        with self._choice():
            with self._option():
                self._NAME_()
            with self._option():
                self._STRING_()
            with self._option():
                self._NUMBER_()
            self._error('expecting one of: /"(\\\\"|[^"])*"/ /[a-z][a-zA-Z0-9_]*/ /\\d+/ NAME NUMBER STRING')

    @tatsumasu('VariableTerm')
    def _variable_term_(self):  # noqa
        with self._choice():
            with self._option():
                self._VARIABLE_()
            with self._option():
                self._token('_')
            self._error('expecting one of: /[A-Z][a-zA-Z0-9_]*/ VARIABLE _')

    @tatsumasu()
    def _arith_op_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('+')
            with self._option():
                self._token('-')
            with self._option():
                self._token('*')
            with self._option():
                self._token('/')
            self._error('expecting one of: * + - /')

    @tatsumasu()
    def _NAME_(self):  # noqa
        self._pattern('[a-z][a-zA-Z0-9_]*')
        self._check_name()

    @tatsumasu()
    def _VARIABLE_(self):  # noqa
        self._pattern('[A-Z][a-zA-Z0-9_]*')

    @tatsumasu('str')
    def _STRING_(self):  # noqa
        self._pattern('"(\\\\"|[^"])*"')

    @tatsumasu('int')
    def _NUMBER_(self):  # noqa
        self._pattern('\\d+')

    @tatsumasu()
    def _start_(self):  # noqa
        self._program_()

    @tatsumasu('ModalLiteral')
    def _modal_literal_(self):  # noqa
        with self._choice():
            with self._option():
                self._NOT_()
                self.name_last_node('negation')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('K')
                        with self._option():
                            self._token('M')
                        self._error('expecting one of: K M')
                self.name_last_node('modality')
                self._cut()
                with self._ifnot():
                    self._NOT_()
                self._naf_literal_()
                self.name_last_node('literal')
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('K')
                        with self._option():
                            self._token('M')
                        self._error('expecting one of: K M')
                self.name_last_node('modality')
                self._cut()
                self._naf_literal_()
                self.name_last_node('literal')
            self._error('expecting one of: K M NOT not')
        self.ast._define(
            ['literal', 'modality', 'negation'],
            []
        )

    @tatsumasu()
    def __body_literal_(self):  # noqa
        with self._choice():
            with self._option():
                self._naf_aggregate_()
            with self._option():
                self._naf_literal_()
            self._error('expecting one of: LNOT NAME NOT aggregate_atom aggregate_name builtin_atom classical_atom naf_aggregate naf_literal not term')


class ELPSemantics(object):
    def program(self, ast):  # noqa
        return ast

    def rule(self, ast):  # noqa
        return ast

    def head(self, ast):  # noqa
        return ast

    def body(self, ast):  # noqa
        return ast

    def body_literal(self, ast):  # noqa
        return ast

    def disjunction(self, ast):  # noqa
        return ast

    def naf_literals(self, ast):  # noqa
        return ast

    def naf_literal(self, ast):  # noqa
        return ast

    def classical_atom(self, ast):  # noqa
        return ast

    def builtin_atom(self, ast):  # noqa
        return ast

    def choice_atom(self, ast):  # noqa
        return ast

    def choice_elements(self, ast):  # noqa
        return ast

    def choice_element(self, ast):  # noqa
        return ast

    def naf_aggregate(self, ast):  # noqa
        return ast

    def aggregate_atom(self, ast):  # noqa
        return ast

    def aggregate_elements(self, ast):  # noqa
        return ast

    def aggregate_element(self, ast):  # noqa
        return ast

    def aggregate_name(self, ast):  # noqa
        return ast

    def rel_op(self, ast):  # noqa
        return ast

    def LAND(self, ast):  # noqa
        return ast

    def LOR(self, ast):  # noqa
        return ast

    def LNOT(self, ast):  # noqa
        return ast

    def NOT(self, ast):  # noqa
        return ast

    def CONS(self, ast):  # noqa
        return ast

    def terms(self, ast):  # noqa
        return ast

    def term(self, ast):  # noqa
        return ast

    def interval_term(self, ast):  # noqa
        return ast

    def single_term(self, ast):  # noqa
        return ast

    def arithmetic_term(self, ast):  # noqa
        return ast

    def basic_term(self, ast):  # noqa
        return ast

    def functional_term(self, ast):  # noqa
        return ast

    def sub_term(self, ast):  # noqa
        return ast

    def negative_term(self, ast):  # noqa
        return ast

    def simple_term(self, ast):  # noqa
        return ast

    def constant_term(self, ast):  # noqa
        return ast

    def variable_term(self, ast):  # noqa
        return ast

    def arith_op(self, ast):  # noqa
        return ast

    def NAME(self, ast):  # noqa
        return ast

    def VARIABLE(self, ast):  # noqa
        return ast

    def STRING(self, ast):  # noqa
        return ast

    def NUMBER(self, ast):  # noqa
        return ast

    def start(self, ast):  # noqa
        return ast

    def modal_literal(self, ast):  # noqa
        return ast

    def _body_literal(self, ast):  # noqa
        return ast


def main(filename, start=None, **kwargs):
    if start is None:
        start = 'program'
    if not filename or filename == '-':
        text = sys.stdin.read()
    else:
        with open(filename) as f:
            text = f.read()
    parser = ELPParser()
    return parser.parse(text, rule_name=start, filename=filename, **kwargs)


if __name__ == '__main__':
    import json
    from tatsu.util import asjson

    ast = generic_main(main, ELPParser, name='ELP')
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(asjson(ast), indent=2))
    print()
