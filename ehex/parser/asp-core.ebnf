@@comments :: /%\*((?:.|\n)*?)\*%/
@@eol_comments :: /%([^*][^\n]*?)?$/
@@whitespace :: /[ \t\n]+/
@@left_recursion :: False

(*   ASP-Core-2 Input Language   *)
(*   Version 2.03b               *)


start = program $ ;


program::Program
    =
    [statements:statements] [query:query]
    ;


statements = {statement} ;


statement = constraint | rule | weak_constraint | optimize ;


constraint::Constraint
    =
    CONS ~ [body:body] DOT
    ;


rule::Rule
    =
    head:head [CONS [body:body]] DOT
    ;


weak_constraint::WeakConstraint
    =
    WCONS [body:body] DOT
    SQUARE_OPEN weight_at_level:weight_at_level SQUARE_CLOSE
    ;


head = disjunction | choice ;


body::RuleBody::Conjunction
    =
    literals:(COMMA).{extended_literal | aggregate_literal}+
    ;


disjunction::Disjunction
    =
    literals:(OR).{classical_literal}+
    ;


choice::ChoiceRelation (* TODO: Review this *)
    =
    | left:term left_op:relational_op choices:choice_set
        [right_op:relational_op right:term]
    | choices:choice_set [right_op:relational_op right:term]
    ;


choice_set = CURLY_OPEN @:choice_elements CURLY_CLOSE;


choice_elements = (SEMICOLON).{choice_element}+ ;


choice_element::ChoiceElement
    =
    choice:classical_literal [COLON [literals:extended_literals]]
    ;


aggregate_literal
    =
    | default_negated_aggreagate
    | aggregate
    ;


default_negated_aggreagate::DefaultNegation
    = op:NOT literal:aggregate
    ;


aggregate::AggregateRelation
    =
    | left:term left_op:relational_op aggregate:aggregate_function
        [right_op:relational_op right:term]
    | aggregate:aggregate_function right_op:relational_op right:term
    ;


aggregate_function::AggregateFunction
    =
    symbol: aggregate_function_symbol CURLY_OPEN
    [!CURLY_CLOSE elements:aggregate_elements] CURLY_CLOSE
    ;


aggregate_function_symbol
    =
    | AGGREGATE_COUNT
    | AGGREGATE_MAX
    | AGGREGATE_MIN
    | AGGREGATE_SUM
    ;


aggregate_elements = (SEMICOLON).{aggregate_element}+ ;


aggregate_element::AggregateElement
    =
    [terms:terms] [COLON [literals:extended_literals]]
    ;


optimize::Optimize
    =
    function:optimize_function CURLY_OPEN
    [elements:optimize_elements] CURLY_CLOSE DOT
    ;


optimize_function = MAXIMIZE | MINIMIZE ;


optimize_elements = (SEMICOLON).{optimize_element}+ ;


optimize_element::OptimizeElement
    =
    weight_at_level:weight_at_level [COLON [literals:extended_literals]]
    ;


query::Query
    =
    literal:classical_literal QUERY_MARK
    ;


classical_literal
    =
    | strong_negated_atom
    | atom
    ;


atom::Atom
    =
    symbol:predicate_symbol [PAREN_OPEN [arguments:terms] PAREN_CLOSE]
    ;


strong_negated_atom::StrongNegation
    =
    op:MINUS atom:atom
    ;


predicate_symbol = !NOT ID ;


builtin_atom::BinaryRelation
    =
    left:term op:relational_op right:term
    ;


extended_literals::Conjunction
    =
    literals:((COMMA).{extended_literal}+)
    ;


extended_literal
    =
    | default_negated_literal
    | classical_literal
    | builtin_atom
    ;


default_negated_literal::DefaultNegation
    =
    op:NOT literal:(classical_literal | builtin_atom)
    ;


weight_at_level::WeighAtLevel
    =
    weight:term [AT level:term] [COMMA terms:terms]
    ;


terms = (COMMA).{term}+ ;


term
    =
    | interval
    | arith_expr
    | basic_term
    ;


arith_expr
    =
    | additive
    | multiplicative
    ;


additive::AdditiveTerm::Term
    =
    @+:arith_term {@:(PLUS | MINUS) ~ @:arith_term}+
    ;


arith_term = multiplicative | basic_term ;


multiplicative::MultiplicativeTerm::Term
    =
    @+:arith_factor {@:(TIMES | DIV) ~ @:arith_factor}+
    ;


arith_factor = basic_term ;


basic_term =
    | subterm
    | negative_term
    | functional
    | constant
    | variable
    ;


interval::Interval
    =
    left:(arith_expr | basic_term) '..' ~ right:term
    ;


functional::FunctionalTerm::Term
    =
    symbol:function_symbol PAREN_OPEN [arguments:terms] PAREN_CLOSE
    ;


function_symbol = ID ;


subterm::SubTerm::Term
    =
    PAREN_OPEN @:term PAREN_CLOSE
    ;


negative_term::NegativeTerm::Term
    =
    MINUS term
    ;


constant::ConstantTerm::Term
    =
    | STRING
    | ID
    | NUMBER
    ;


variable::VariableTerm::Term
    =
    | VARIABLE
    | ANONYMOUS_VARIABLE
    ;


relational_op
    =
    | LESS_OR_EQ
    | GREATER_OR_EQ
    | UNEQUAL
    | EQUAL
    | LESS
    | GREATER
    ;


ID = /[a-z][a-zA-Z0-9_]*/ ;
VARIABLE = /[A-Z][a-zA-Z0-9_]*/ ;
STRING::str = /"(\\"|[^"])*"/;
NUMBER::int = /0|\d+/ ;
ANONYMOUS_VARIABLE = '_' ;
DOT = '.' ;
COMMA = ',' ;
QUERY_MARK = '?' ;
COLON = ':' ;
SEMICOLON = ';' ;
OR = '|';
NOT = 'not' ;
CONS = ':-';
WCONS = ':~' ;
PLUS = '+' ;
MINUS = '-' ;
TIMES = '*' ;
DIV = '/' ;
AT = '@' ;
PAREN_OPEN = '(' ;
PAREN_CLOSE = ')' ;
SQUARE_OPEN = '[' ;
SQUARE_CLOSE = ']' ;
CURLY_OPEN = '{' ;
CURLY_CLOSE = '}' ;
EQUAL = '=' ;
UNEQUAL = '<>' | '!=' ;
LESS = '<' ;
GREATER = '>' ;
LESS_OR_EQ = '<=' ;
GREATER_OR_EQ = '>=' ;
AGGREGATE_COUNT = '#count' ;
AGGREGATE_MAX = '#max' ;
AGGREGATE_MIN = '#min' ;
AGGREGATE_SUM = '#sum' ;
MINIMIZE = '#minimi' /[zs]/ 'e' ;
MAXIMIZE = '#maximi' /[zs]/ 'e' ;
