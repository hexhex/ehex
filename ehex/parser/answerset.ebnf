@@grammar :: HEXAnswerSet


start = result $ ;

result
    =
    answer_sets
    ;


answer_sets = {answer_set}*;


answer_set::set
    =
    CURLY_OPEN ~ @:literals CURLY_CLOSE
    ;


literals = (COMMA).{literal}*;


literal
    =
    | epistemic_rejection
    | strong_negated_atom
    | atom
    ;


atom::Atom
    =
    symbol:predicate_symbol [PAREN_OPEN [arguments:terms] PAREN_CLOSE]
    ;


strong_negated_atom::StrongNegation
    =
    | op:MINUS ~ atom:atom
    | [AUX_MARKER] SNEG_PREFIX ~ op:() /_/ atom:atom
    ;


epistemic_rejection
    =
    AUX_MARKER GUESS_PREFIX ~ PAREN_OPEN @:(modal | default_negated_modal) PAREN_CLOSE
    ;


modal::Modal
    =
    [AUX_MARKER] op:(K_PREFIX | M_PREFIX) ~ /_/ literal:(strong_negated_atom | atom)
    ;


default_negated_modal::DefaultNegation
    =
    AUX_MARKER op:DNEG_PREFIX ~ /_/ literal:modal
    ;


predicate_symbol = ID ;


terms = (COMMA).{term}+ ;


term =
    | functional
    | constant
    | negative_term
    ;


functional::FunctionalTerm::Term
    =
    symbol:function_symbol PAREN_OPEN ~ [arguments:terms] PAREN_CLOSE
    ;


function_symbol = ID ;


negative_term::NegativeTerm::Term
    =
    MINUS ~ term
    ;


constant::ConstantTerm::Term
    =
    | STRING
    | ID
    | NUMBER
    ;


ID = /[a-z][a-zA-Z0-9_]*/ ;
STRING = /"(?:\\"|[^"])*"/;
NUMBER::int = /0|\d+/ ;
COMMA = ',' ;
PLUS = '+' ;
MINUS = '-' ;
TIMES = '*' ;
DIV = '/' ;
PAREN_OPEN = '(' ;
PAREN_CLOSE = ')' ;
CURLY_OPEN = '{' ;
CURLY_CLOSE = '}' ;

AUX_MARKER = /aux__/ ;
DNEG_PREFIX = /NOT/ ;
K_PREFIX = /K/ ;
M_PREFIX = /M/ ;
SNEG_PREFIX = /NEG/ ;
GUESS_PREFIX = /IN/ ;
